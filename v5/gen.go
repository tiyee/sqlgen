package v5

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"strings"
)

func fieldTypeConvert(t FieldType) string {
	switch t {
	case tTINYINT:
		return "int8"
	case tSMALLINT:
		return "int16"
	case tMEDIUMINT:
		return "int"
	case tINT:
		return "int"
	case tBIGINT:
		return "int64"
	case tCHAR, tVARCHAR:
		return "string"
	case tTIMESTAMP:
		return "time.Time"
	default:
		return "string"
	}
}
func exportName(s string) string {
	if strings.Index(s, "_") > 0 {
		arr := strings.Split(s, "_")
		for i, item := range arr {
			if len(item) > 0 {
				arr[i] = strings.ToUpper(item[0:1]) + item[1:]
			}
		}
		return strings.Join(arr, "")
	}
	return strings.ToUpper(s[0:1]) + s[1:]

}

type Creator CreateTableStmt

func (c *Creator) StructName() string {
	if len(c.NameNode.s) == 1 {
		return strings.ToUpper(c.NameNode.s)
	}
	return exportName(c.NameNode.s)
}
func (c *Creator) Create() *ast.GenDecl {

	fields := make([]*ast.Field, 0, len(*c.ColumnsStmt))
	for _, field := range *c.ColumnsStmt {
		fields = append(fields, &ast.Field{
			Names: []*ast.Ident{
				&ast.Ident{
					Name: exportName(field.NameNode.s),
				},
			},
			Type: &ast.Ident{
				Name: fieldTypeConvert(field.t),
			},
			Tag: &ast.BasicLit{
				Kind:  token.STRING,
				Value: fmt.Sprintf("`json:\"%s\"`", field.NameNode.s),
			},

			Comment: &ast.CommentGroup{
				List: []*ast.Comment{
					&ast.Comment{
						Text: "//" + field.CommentNode.s,
					},
				},
			},
		})
	}
	ret := &ast.GenDecl{

		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: &ast.Ident{
					Name: c.StructName(),
				},
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: fields,
					},
				},
			},
		},
	}

	return ret
}
func (c *Creator) makeFunc(funcName, ret string) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				&ast.Field{
					Names: []*ast.Ident{
						&ast.Ident{
							Name: strings.ToLower(c.NameNode.s[0:1]),
						},
					},
					Type: &ast.StarExpr{
						X: &ast.Ident{
							Name: c.StructName(),
						},
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: funcName,
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					&ast.Field{
						Type: &ast.Ident{
							Name: "string",
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.BasicLit{
							Kind:  token.STRING,
							Value: fmt.Sprintf("\"%s\"", ret),
						},
					},
				},
			},
		},
	}
}
func (c *Creator) PkFunc() *ast.FuncDecl {
	if primary, exist := c.TableIndexListStmt.Find(idxPrimary); exist {
		return c.makeFunc("Pk", primary.NameListStmt[0].s)
	}
	return c.makeFunc("Pk", "id")

}
func (c *Creator) TableFunc() *ast.FuncDecl {
	return c.makeFunc("TableName", c.NameNode.s)
}
func (c *Creator) Save(wr io.Writer) error {

	cm := "// Code generated by log-gen. DO NOT EDIT.\n"
	ff := &ast.File{
		Package: token.Pos(len(cm) + 1),
		Name: &ast.Ident{
			Name:    "models",
			NamePos: token.Pos(len("Package") + 2),
		}}

	if c.ColumnsStmt != nil {
		fn := func(col *ColumnStmt) bool {
			return col.t == "timestamp"
		}
		if c.ColumnsStmt.ExistF(fn) {
			ff.Decls = append(ff.Decls, &ast.GenDecl{
				Tok: token.IMPORT,
				Specs: []ast.Spec{
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							Kind:  token.STRING,
							Value: fmt.Sprintf("\"%s\"", "time"),
						},
					},
				},
			})
		}
	}

	ff.Decls = append(ff.Decls,
		c.Create(),
		c.PkFunc(),
		c.TableFunc(),
	)
	//fmt.Println("len:", len(ff.Decls))
	if _, err := wr.Write([]byte(cm)); err != nil {
		return err
	}
	if err := format.Node(wr, token.NewFileSet(), ff); err != nil {
		return err
	} else {
		return err
	}

}
