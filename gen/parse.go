package gen

import (
	"fmt"
	"github.com/pingcap/tidb/parser"
	"github.com/pingcap/tidb/parser/ast"
	"github.com/pingcap/tidb/parser/mysql"
	_ "github.com/pingcap/tidb/parser/test_driver"
	goast "go/ast"
	"go/format"
	"go/token"
	"io"
)

func parse(sql string) (*ast.StmtNode, error) {
	p := parser.New()

	stmtNodes, _, err := p.Parse(sql, "", "")
	if err != nil {
		return nil, err
	}
	return &stmtNodes[0], nil
}
func New() *StructCreator {
	return &StructCreator{PackageName: "models"}
}

type ColumnValueType byte

func (cv ColumnValueType) String() string {
	t := byte(cv)
	switch t {
	case mysql.TypeTiny:
		return "int8"
	case mysql.TypeShort:
		return "int16"
	case mysql.TypeInt24:
		return "int"
	case mysql.TypeLong:
		return "int"
	case mysql.TypeLonglong:
		return "int64"
	case mysql.TypeString, mysql.TypeVarchar, mysql.TypeVarString:
		return "string"
	case mysql.TypeBlob, mysql.TypeLongBlob, mysql.TypeMediumBlob:
		return "string"
	case mysql.TypeDouble:
		return "double"
	case mysql.TypeFloat:
		return "float"
	case mysql.TypeDate:
		return "date"
	case mysql.TypeDatetime:
		return "time.Time"
	case mysql.TypeTimestamp:
		return "time.Time"
	default:
		return ""

	}
}

func (c *StructCreator) Enter(in ast.Node) (ast.Node, bool) {
	if ct, ok := in.(*ast.CreateTableStmt); ok {
		c.TableName = ct.Table.Name.String()
		c.Fields = make([]StructField, 0, len(ct.Cols))
		for _, col := range ct.Cols {
			tp := ColumnValueType(col.Tp.GetType()).String()
			if tp == "" {
				panic("error")
			}
			if tp == "time.Time" {
				c.HasTime = true
			}

			if mysql.HasUnsignedFlag(col.Tp.GetFlag()) {
				tp = "u" + tp
			}
			c.Fields = append(c.Fields, StructField{
				Name:    exportName(col.Name.Name.String()),
				Type:    tp, // col.Tp.GetType()
				Tag:     fmt.Sprintf("`json:\"%s\"`", col.Name.Name.String()),
				Comment: fmt.Sprintf("// %s%d", col.Tp.String(), len(col.Options)),
			})

			//if mysql.HasPriKeyFlag(col.Tp.GetFlag()) {
			//	c.Pk = col.Name.Name.String()
			//}
			if c.Pk == "" {
				for _, op := range col.Options {
					if op.Tp == ast.ColumnOptionPrimaryKey || op.Tp == ast.ColumnOptionAutoIncrement {
						c.Pk = col.Name.Name.String()
						break
					}
				}
			}

		}
	}
	return in, false
}
func (c *StructCreator) Leave(in ast.Node) (ast.Node, bool) {
	return in, true
}
func Parse(s string, wr io.Writer) error {
	astNode, err := parse(s)
	if err != nil {
		fmt.Printf("parse error: %v\n", err.Error())
		return err
	}
	sc := New()
	(*astNode).Accept(sc)
	cm := "// Code generated by log-gen. DO NOT EDIT.\n"
	ff := &goast.File{
		Package: token.Pos(len(cm) + 1),
		Name: &goast.Ident{
			Name:    sc.PackageName,
			NamePos: token.Pos(len("Package") + 2),
		}}

	if sc.HasTime {
		ff.Decls = append(ff.Decls, &goast.GenDecl{
			Tok: token.IMPORT,
			Specs: []goast.Spec{
				&goast.ImportSpec{
					Path: &goast.BasicLit{
						Kind:  token.STRING,
						Value: fmt.Sprintf("\"%s\"", "time"),
					},
				},
			},
		})
	}
	ff.Decls = append(ff.Decls,
		sc.Create(),
		sc.PkFunc(),
		sc.TableFunc(),
	)
	if _, err := wr.Write([]byte(cm)); err != nil {
		return err
	}
	if err = format.Node(wr, token.NewFileSet(), ff); err != nil {
		return err
	} else {
		return err
	}

}
